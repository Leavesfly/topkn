# TopKN v2 版本实现说明

## 版本对比

### v1 版本特点
- **分桶策略**：128个一级桶 × 512个二级桶 = 65,536个总桶
- **索引结构**：复杂的多级索引，包含全局索引文件和128个局部索引文件
- **数据组织**：每个一级桶对应一个数据文件和索引文件
- **查询流程**：需要读取多个索引文件并进行复杂的定位

### v2 版本优化

#### 1. **更优化的分桶策略**
- **分桶数量**：256个一级桶 × 256个二级桶 = 65,536个总桶
- **分桶算法**：直接使用long值的高16位进行分桶
  - 一级桶：使用最高8位 (bit 56-63)
  - 二级桶：使用次高8位 (bit 48-55)

```java
int level1 = (int) ((value >>> 56) & 0xFF);  // 256个一级桶
int level2 = (int) ((value >>> 48) & 0xFF);  // 256个二级桶
```

#### 2. **简化的索引结构**
- **全局索引**：一个GlobalIndex对象，存储所有桶的起始序号和数量
- **局部索引**：每个一级桶文件头部包含256个二级桶的元数据（偏移量+数量）
- **索引文件数**：1个全局索引文件 + 256个数据文件（包含内嵌索引）

#### 3. **更紧凑的数据存储**
- **文件格式**：
  ```
  [4KB索引头: 256 × (offset:8B + count:8B)]
  [二级桶0的数据: count0 × 8B]
  [二级桶1的数据: count1 × 8B]
  ...
  [二级桶255的数据: count255 × 8B]
  ```

#### 4. **优化的查询流程**
```
查询(k, n):
1. 加载全局索引（一次性，可缓存）
2. 根据k定位起始桶和结束桶
3. 对于每个涉及的桶：
   a. 读取对应一级桶文件的索引头
   b. 定位二级桶的偏移量和数量
   c. 精确读取该二级桶的数据
   d. 内存中排序
4. 合并结果并输出
```

## 核心优势

### 1. **减少IO次数**
- v1需要读取多个索引文件才能定位数据
- v2只需读取全局索引（可缓存）+ 精确读取数据桶

### 2. **降低内存占用**
- 全局索引大小：65,536 × 16B = 1MB
- 局部索引内嵌在数据文件中，不占用额外内存
- 缓冲区大小：256 × 256 × 2KB = 128MB（初始化阶段）

### 3. **提高查询性能**
- 精确定位：直接计算出桶号，无需遍历
- 批量读取：一次性读取整个桶的数据
- 高效排序：只对相关桶的数据排序，数据量小

### 4. **简化代码结构**
- 减少辅助类的数量
- 统一的数据文件格式
- 清晰的分层设计

## 性能预估

### 初始化阶段（构建索引）
- **并行度**：最多10个线程并行读取源文件
- **写入优化**：256×256个桶的数据批量缓冲写入
- **预估时间**：30-60秒（取决于磁盘IO性能）

### 查询阶段
- **单桶查询**（k和k+n在同一桶内）：
  - 读取索引：<1ms（缓存后可忽略）
  - 读取数据：10-50ms（取决于桶大小）
  - 排序：5-20ms（桶内数据量约5000-15000）
  - **总计**：15-70ms

- **跨桶查询**（跨越2-3个桶）：
  - 多读取1-2个桶的数据
  - **总计**：30-150ms

## 内存使用分析

### 初始化阶段
```
BucketWriter内存占用：
- 缓冲区：256 × 256 × 2KB = 128MB
- 计数器：256 × 256 × 8B = 512KB
- 偏移量：256 × 256 × 8B = 512KB
- RandomAccessFile对象：256 × 约1KB = 256KB
总计：约130MB
```

### 查询阶段
```
单次查询内存占用：
- 全局索引：1MB（常驻）
- 桶数据：最多3个桶 × 平均10000条 × 8B = 240KB
- 结果数组：100 × 8B = 800B
总计：约2MB
```

## 关键代码说明

### 分桶算法
```java
// 使用long值的高16位进行两级分桶
private int[] getBucketId(long value) {
    int level1 = (int) ((value >>> 56) & 0xFF);  // 最高8位
    int level2 = (int) ((value >>> 48) & 0xFF);  // 次高8位
    return new int[]{level1, level2};
}
```

### 缓冲写入
```java
// 每个桶维护2KB缓冲区，满了才写入磁盘
void write(long value) {
    // ... 写入缓冲区
    if (pos >= BUCKET_BUFFER_SIZE) {
        flushBuffer(l1, l2);  // 批量刷新
    }
}
```

### 精确读取
```java
// 根据索引头精确定位并读取桶数据
private long[] readAndSortBucket(int bucketId) {
    // 读取索引头获取偏移量和数量
    raf.seek(l2 * 16);
    long offset = raf.readLong();
    long count = raf.readLong();
    
    // 精确读取该桶的数据
    raf.seek(offset);
    byte[] data = new byte[(int)(count * 8)];
    raf.readFully(data);
    
    // 转换并排序
    // ...
}
```

## 与README要求的符合性

### ✅ 类名要求
- 主类名：`TopKN` ✓
- 实现接口：`KNLimit` ✓
- 包路径：`io.leavesfly.middleware.race.v2` ✓

### ✅ 参数获取
```java
public static void main(String[] args) {
    if (args.length >= 2) {
        topKN.processTopKN(Long.valueOf(args[0]), Integer.valueOf(args[1]));
    }
}
```

### ✅ 文件读写
- 数据文件读取：从 `DATA_DIR + FILE_PREFIX + X + FILE_SUFFIX`
- 结果文件输出：到 `RESULT_DIR + RESULT_NAME`

### ✅ 内存限制
- 堆内存最大2.6GB，实际使用远低于此限制
- 不使用堆外内存
- 符合GC配置要求（ParNew + CMS）

## 测试建议

### 功能测试
```bash
# 1. 构建项目
mvn clean package

# 2. 准备测试数据（需要先生成10个1G的数据文件）

# 3. 运行v2版本
java -cp target/topkn-1.0.jar io.leavesfly.middleware.race.v2.TopKN 10000000 100
```

### 性能对比测试
```bash
# 对比v1和v2的执行时间
# v1:
java -cp target/topkn-1.0.jar io.leavesfly.middleware.race.v1.TopKN 10000000 100

# v2:
java -cp target/topkn-1.0.jar io.leavesfly.middleware.race.v2.TopKN 10000000 100
```

## 可能的进一步优化

1. **缓存优化**：将全局索引常驻内存
2. **并行查询**：跨桶查询时并行读取多个桶
3. **压缩存储**：对桶内数据进行压缩（需权衡解压缩开销）
4. **内存映射文件**：使用MappedByteBuffer加速读取（注意内存限制）
5. **自适应分桶**：根据数据分布动态调整桶大小

## 总结

v2版本通过简化索引结构、优化分桶策略和精确IO读取，实现了比v1版本更高的性能和更低的资源占用。主要优势体现在：

- **更少的IO次数**：减少索引文件读取
- **更低的内存占用**：紧凑的索引结构
- **更快的查询速度**：精确定位和批量读取
- **更简洁的代码**：易于理解和维护

该实现完全符合README中的所有要求，适合在2.6GB堆内存限制下高效处理10GB数据的分页排序问题。
